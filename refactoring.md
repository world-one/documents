### Refactoring
겉으로 드러나는 기능은 바꾸지 않으면서 내부 구조를 개선하는 것   
즉, 코드 작성 후 설계 개선

1. 리팩터링 : 첫 번째 예시
   - 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 
   - 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시하라. 리팩터링 때문에 성능이 떨어진다면, 이후에 개선하자.
   - 함수를 변수에 담아 사용하기 보다는 함수 자체를 인라인으로 쓰는 것을 권장함.
   - 단계를 엄청 잘게 쪼개서 해당 단계를 마치면 컴파일-테스트-커밋을 진행..
   - 도착했을 때보다 깔끔하게 정돈하고 떠난다.
   - 리팩터링을 하고 난 후 코드가 명확해지 이해하기 더 쉬워진다.
   - 얼마나 수정하기 쉬운가가 좋은 코드를 가늠하는 기준이 된다.
2. 리팩터링 원칙
   -  정의 
      - (명사)겉보기 동작은 그대로 유지하며 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
      - (동사)겉보기 동작은 그대로 유지하며, 여러가지 리팩터링 기법을 적용하여 소프트웨어를 재구성하다.
   - 동작을 보존하는 작은 단계들을 거치며 코드를 정리하는 것 
   - 두개의 모자
      - 기능 추가시에는 기존 코드를 건드리지 않고 새 기능을 추가한다.
      - 리팩터링시에는 코드 재구성만 한다.
   - 해야하는 이유
     - 소프트웨어 설계가 좋아진다.
     - 소프트웨어를 이해하기 쉬워진다.
     - 버그를 쉽게 찾을 수 있다.
     - 프로그래밍 속도를 높일 수 있다.
   - 언제 해야 할까?
      - 3의 법칙
        - 그냥 하다가 두번째 중복까지는 진행, 세번째엔 리팩터링
      - 준비를 위한 - 기능 쉽게 추가하도록
      - 이해를 위한 - 코드를 이해하기 쉽도록
      - 쓰레기 줍기 - 시간을 많이 쓰고 싶지 않다면 조금이라도
      - 계획된 리팩터링, 수시 리팩터링
      - 오래 걸리는 리팩터링
      - 코드 리뷰
      - 하지말아야 할 때(판단력과 경험이 중요하다.)
        - 내부 동작을 이해하지 못 할 때
        - 처음부터 작성하는게 쉬울 경우 
   - 고려할 문제
      - 새 기능 개발 속도 저하
        - 코드 베이스를 예쁘게 하는게 아닌 경제적인 이유로 하는 것이다. 개발 기간, 기능 추가 시간, 버그 수정시간 단축 등
      - 코드 소유권
        - 코드 소유권을 느슨하게 하여 담당자가 아니어도 수정이 가능하도록
      - 브랜치
        - 지속적 통합(Continue Integration)
        - 트렁크 기반 개발(Trunk-Based Development)
      - 테스팅
      - 레거시 코드
      - 데이터베이스
    - 리팩터링, 아키텍처, 애그니(YAGNI) 
      - 간결한 설계, 점진적 설계, you aren`t going to need it
      - 그냥 현재까지 파악한 요구사항을 멋지게 해결하도록 한다.
    - 리팩터링과 소프트웨어 개발 프로세스
      - TDD
    - 성능
      - 리팩터링 단계에서는 성능을 고려하진 않아서 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하는 것이 쉬워진다.
    - 리팩터링의 유래
      - 워드 커닝햄, 켄트 백, 랄프 존스, 빌 옵다이크, 존 브랜트, 돈 로버츠 
    - 리팩터링 자동화
      - 인텔리 제이, 이클립스 등 자동 리팩터리을 지원하는 도구
      - 소스 코드의 텍스트를 직접 조작하는 방법은 어설프지만, 첫 발을 내딛는 데는 유용하다.
      - 리팩터링 도구들은 안전하지만 간혹 문제를 일으킨다. 그래서 자동와 수동을 적절히 함께 사용해주면 테스트도 충분히 거친다.
      - 언어 서버, language server
    - 더 알고 싶다면
      - 윌리엄 웨이크의 리팩터링 워크북
      - 조슈아 케리에프스카의 패턴을 활용한 리팩터링
      - 스캇 엠블러와 프라모드 사달게의 리팩토링 데이터베이스
      - 엘리엇 러스티 해롤드의 리팩토링 html
      - 마이클 페더스의 레거시 코드 활용 전략
      - https://github.com/WegraLee/Refactoring
      - https://www.refactoring.com/
3. 코드에서 나는 악취
  - 기이한 이름
  - 중복 코드
  - 긴 함수
    - 적절한 이름으로 함수 쪼개기
    - 주석을 달아야 할 부분은 함수로 만들기
    - 의도가 드러나는 이름
    - 성격이 다른 작업이 섞여 있다면 분리
  - 긴 매개변수 목록
  - 전역 데이터
  - 가변 데이터
  - 뒤엉킨 변경
    - 단일 책임 원칙이 제대로 지켜지지 않을 때
  - 산탄총 수술
    - 코드 수정 시 자잘하게 수정해야하는 곳이 많을 때
  - 기능 편애
    - 함께 변경할 대상을 한데 모으는 것
  - 데이터 뭉치
    - 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야한다.
  - 기본형 집착(기본 타입에 대한 강박관념)
    - 문제에 맞는 기초형 타입을 직접 정의하는 것?
  - 반복되는 switch문
    - 조건부 로직을 다형성으로 바꾸기
  - 반복문
    - 반복문을 파이프라인으로 바꾸기
  - 성의 없는 요소
    - 역할이 줄어든 프로그램 요소는 제거작업 진행
  - 추측성 일반화
    - 미래를 대비해 작성한(사용되지 않는) 부분은 쓸데없는 낭비이니 제거하자
  - 임시 필드
    - 특정 상황에서만 값이 설정되는 필드에 대한 처리
  - 메시지 체인
    - 위임 숨기기
      ```
      aPerson.department.manageName
      aPerson.manage.name
      aPerson.manageName
      ```
  - 중개자
  - 내부자 거래
    - 결합도가 높을 때, 데이터 거래를 줄이고 투명하게 처리해야 한다.
  - 거대한 클래스
  - 서로 다른 인터페이스의 대안 클래스들
  - 데이터 클래스
    - 데이터 필드와 게터/세터로만 구성된 클래스
  - 상속 포기
  - 주석
    - 주석을 달지 말라는건 아니지만, 장황하게 달린 코드는 잘못 작성된 경우가 많다.

4. 테스트 구축하기
  - 자가 테스트 코드의 가치
    - 모든 테스트의 완전 자동화와 결과 검사까지 하도록
    - 회귀 버그, 회귀 테스트
    - 테스트 주도 개발(TDD) 
      - 테스트 - 코딩 - 리팩터링
    - 테스트 프레임워크 - 책에서는 mocha 사용
    - 테스트 추가하기
      - 위험 요인 중심으로, 너무 많이 만들지 않도록 하자(불피룡한 부분)
      - 테스트끼리 상호 작용하는 공유 픽스터를 생성하지 않도록 한다.
    - 픽스처 수정
      - 테스트 패턴, 설정 - 실행 - 검증 / 조건 - 발생 - 결과 / 준비 - 수행 - 단언
    - 경계 조건 검사
      - happy path를 벗어나는 경계 지점에서 문제가 생길 경우
      - 문제가 생길 가능성이 있는 경계 조건을 생각하고 집중적으로 테스트
    - 끝나지 않은 여정
      - 버그 리포트를 받으면 그 버그의 단위 테스트부터 작성하자.

5. 리팩터링 카탈로그 보는 법
  - 리팩터링 설명 형식
    - 이름
    - 개요
    - 배경
    - 절차
    - 예시
  - 리팩터링 기법 선정 기준
    - 유용함, 간단하고 직관적인 건 생략
6. 기본적인 리팩터링
  - 함수 추출하기(extract function)
    - 목적과 구현을 분리
    - 함수의 이름이 구현 코드가 길어도 문제가 되지 않는다.
    - 짧은 함수들이 많아져 호출이 늘어날 경우 성능에 대한 문제는 걱정하지 말자
      - 컴파일러가 짧은 함수들을 쉽게 캐싱하여 최적화하는데 유리할 때도 있다.
    - 성능 최적화, 하지마라... 아직 하지마라...
    - 절차
      - 함수를 만들고 목적을 드러내는 이름을 붙인다.
      - 추출할 코드를 원본에서 복사하여 새 함수에 넣는다.       
      - 지역 변수를 참조하거나 유효범위를 벗어나는 변수는 없는지 검사하여 매개변수로 전달한다.
      - 변수를 다 처리했다면 컴파일한다.
      - 원본 함수에서 추출한 코드 부분을 함수를 호출하는 문장으로 바꾼다.
      - 테스트
      - 다른 코드에 똑같거나 비슷한 곳이 있는지 확인후 수정
  - 함수 인라인하기(Inline Function)
    - 함수 본문이 이름만큼 명확한 경우는 함수를 제거한다.
    - 절차
      - 다형 메서드인지 확인
      - 인라인할 함수를 호출하는 곳을 찾는다.
      - 호출문을 본문으로 교체
      - 교체시 마다 테스트
      - 원래 함수를 제거
    - 단계를 잘게 나눠서 처리하자
  - 변수 추출하기(Extract Variable)
    - 표현식이 복잡해서 이해하기 어려울 경우 지역 변수를 활용하면 쪼개서 관리하기 쉽다.
    - 단계마다 이름을 붙여 코드의 목적 더 명확해 진다.
    - class 객체를 이용한 장점은 특정 로직과 데이터를 외부와 공유하려 할 때 이를 설명해주는 적당한 크기의 문맥이 되어준다.
  - 변수 인라인하기(Inline Variable)
    - 변수와 원래의 표현식이 다를 바 없을 경우 인라인 하는 것이 좋다.
  - 함수 선언 바꾸기
    - 함수의 이름
    - 간단한 절차와 마이그레이션 절차
    - 매개 변수 추가하기
    - 매개 변수를 속성으로 바꾸기
  - 변수 캡슐화하기(Encapsulate variable)
    - 데이터를 변경하고 사용하는 코드를 감시할 수 있다.
    - 절차
      - 변수 접근과 갱신을 전담하는 캡슐화 함수를 만든다.
      - 정적 검사
      - 변수 직접 참조하는 부분을 캡슐화 함수 호출로 변경
      - 변수의 접근 범위를 제한
  - 변수 이름 바꾸기(Rename Variable)
  - 매개변수 객체 만들기(Introduce Parameter Object)
  - 여러 함수를 클래스로 묶기(Combine Functions into Class)
    - 클래스로 묶을 때의 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다.
    - 중첩 함수 형태로 묶을 수도 있지만 테스트가 까다로울 수 있다.
    - 절차
      - 함수들이 공유하는 공통 데이터 레코드 캡슐화
      - 공통 레코드를 사용하는 함수를 클래스로 이동
      - 데이터 조작 로직은 함수로 추출해서 새 클래스로 이동  
  - 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)
    - 같은 로직이 반복되는 것들은 한곳에 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
    - 데이터의 일관성이 깨질 수 있어서, 자바스크립트에서는 이 문제를 해결하기 위해서 클래스로 묶기가 좋은 방법으로 보인다.
    - 불변 데이터 구조를 지원하는 언어는 이런 문제가 생길 일이 없어서 변환 함수로 묶기를 사용하는 비중이 높다.
  - 6.11 단계 쪼개기(Split Phase)
    - 다른 단계로 볼 수 있는 코드 영역들이 서로 다른 데이터와 함수를 사용한다면 단계 쪼개기에 적합하다.
    - 테스트를 쉽게 수행할 수 있도록 수정한 다음에 리팩토링하는게 좋다.
    - 험블 객체 패턴: 명령문 호출과 표준 출력에 쓰는 느리고 불편한 작업과 자주 테스트 해야 할 복잡한 동작을 분리
    - 첫번째 단계에서 객체를 변환기로 사용하기
7. 캡슐화
  -  모듈 분리의 가장 중요한 기준은 각 모듈이 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다.
  - 7.1 레코드 캡슐화하기 (Encapsulate Record)
    - 중첩된 리스트나 해시맵을 캡슐화하면 포맷을 바꾸거나 추적하기 어려운 데이터를 수정하기 수월해진다.
    - 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위해서다.
8. 기능 이동
9. 데이터 조직화
10. 조건부 로직 간소화
11. API 리팩터링
12. 상속 다루기