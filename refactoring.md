### Refactoring
겉으로 드러나는 기능은 바꾸지 않으면서 내부 구조를 개선하는 것   
즉, 코드 작성 후 설계 개선

1. 리팩터링 : 첫 번째 예시
   - 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 
   - 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시하라. 리팩터링 때문에 성능이 떨어진다면, 이후에 개선하자.
   - 함수를 변수에 담아 사용하기 보다는 함수 자체를 인라인으로 쓰는 것을 권장함.
   - 단계를 엄청 잘게 쪼개서 해당 단계를 마치면 컴파일-테스트-커밋을 진행..
   - 도착했을 때보다 깔끔하게 정돈하고 떠난다.
   - 리팩터링을 하고 난 후 코드가 명확해지 이해하기 더 쉬워진다.
   - 얼마나 수정하기 쉬운가가 좋은 코드를 가늠하는 기준이 된다.
2. 리팩터링 원칙
   -  정의 
      - (명사)겉보기 동작은 그대로 유지하며 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
      - (동사)겉보기 동작은 그대로 유지하며, 여러가지 리팩터링 기법을 적용하여 소프트웨어를 재구성하다.
   - 동작을 보존하는 작은 단계들을 거치며 코드를 정리하는 것 
   - 두개의 모자
      - 기능 추가시에는 기존 코드를 건드리지 않고 새 기능을 추가한다.
      - 리팩터링시에는 코드 재구성만 한다.
   - 해야하는 이유
     - 소프트웨어 설계가 좋아진다.
     - 소프트웨어를 이해하기 쉬워진다.
     - 버그를 쉽게 찾을 수 있다.
     - 프로그래밍 속도를 높일 수 있다.
   - 언제 해야 할까?
      - 3의 법칙
        - 그냥 하다가 두번째 중복까지는 진행, 세번째엔 리팩터링
      - 준비를 위한 - 기능 쉽게 추가하도록
      - 이해를 위한 - 코드를 이해하기 쉽도록
      - 쓰레기 줍기 - 시간을 많이 쓰고 싶지 않다면 조금이라도
      - 계획된 리팩터링, 수시 리팩터링
      - 오래 걸리는 리팩터링
      - 코드 리뷰
      - 하지말아야 할 때(판단력과 경험이 중요하다.)
        - 내부 동작을 이해하지 못 할 때
        - 처음부터 작성하는게 쉬울 경우 
   - 고려할 문제
      - 새 기능 개발 속도 저하
        - 코드 베이스를 예쁘게 하는게 아닌 경제적인 이유로 하는 것이다. 개발 기간, 기능 추가 시간, 버그 수정시간 단축 등
      - 코드 소유권
        - 코드 소유권을 느슨하게 하여 담당자가 아니어도 수정이 가능하도록
      - 브랜치
        - 지속적 통합(Continue Integration)
        - 트렁크 기반 개발(Trunk-Based Development)
      - 테스팅
      - 레거시 코드
      - 데이터베이스
    - 리팩터링, 아키텍처, 애그니(YAGNI) 
      - 간결한 설계, 점진적 설계, you aren`t going to need it
      - 그냥 현재까지 파악한 요구사항을 멋지게 해결하도록 한다.
    - 리팩터링과 소프트웨어 개발 프로세스
      - TDD
    - 성능
      - 리팩터링 단계에서는 성능을 고려하진 않아서 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하는 것이 쉬워진다.
    - 리팩터링의 유래
      - 워드 커닝햄, 켄트 백, 랄프 존스, 빌 옵다이크, 존 브랜트, 돈 로버츠 
    - 리팩터링 자동화
      - 인텔리 제이, 이클립스 등 자동 리팩터리을 지원하는 도구
      - 소스 코드의 텍스트를 직접 조작하는 방법은 어설프지만, 첫 발을 내딛는 데는 유용하다.
      - 리팩터링 도구들은 안전하지만 간혹 문제를 일으킨다. 그래서 자동와 수동을 적절히 함께 사용해주면 테스트도 충분히 거친다.
      - 언어 서버, language server
    - 더 알고 싶다면
      - 윌리엄 웨이크의 리팩터링 워크북
      - 조슈아 케리에프스카의 패턴을 활용한 리팩터링
      - 스캇 엠블러와 프라모드 사달게의 리팩토링 데이터베이스
      - 엘리엇 러스티 해롤드의 리팩토링 html
      - 마이클 페더스의 레거시 코드 활용 전략
      - https://github.com/WegraLee/Refactoring
      - https://www.refactoring.com/
3. 코드에서 나는 악취
  - 기이한 이름
  - 중복 코드
  - 긴 함수
    - 적절한 이름으로 함수 쪼개기
    - 주석을 달아야 할 부분은 함수로 만들기
    - 의도가 드러나는 이름
    - 성격이 다른 작업이 섞여 있다면 분리
  - 긴 매개변수 목록
  - 전역 데이터
  - 가변 데이터
  - 뒤엉킨 변경
    - 단일 책임 원칙이 제대로 지켜지지 않을 때
  - 산탄총 수술
    - 코드 수정 시 자잘하게 수정해야하는 곳이 많을 때
  - 기능 편애
    - 함께 변경할 대상을 한데 모으는 것
  - 데이터 뭉치
    - 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야한다.
  - 기본형 집착(기본 타입에 대한 강박관념)
    - 문제에 맞는 기초형 타입을 직접 정의하는 것?
  - 반복되는 switch문
    - 조건부 로직을 다형성으로 바꾸기
  - 반복문
    - 반복문을 파이프라인으로 바꾸기
  - 성의 없는 요소
    - 역할이 줄어든 프로그램 요소는 제거작업 진행
  - 추측성 일반화
    - 미래를 대비해 작성한(사용되지 않는) 부분은 쓸데없는 낭비이니 제거하자
  - 임시 필드
    - 특정 상황에서만 값이 설정되는 필드에 대한 처리
  - 메시지 체인
    - 위임 숨기기
      ```
      aPerson.department.manageName
      aPerson.manage.name
      aPerson.manageName
      ```
  - 중개자
  - 내부자 거래
    - 결합도가 높을 때, 데이터 거래를 줄이고 투명하게 처리해야 한다.
  - 거대한 클래스
  - 서로 다른 인터페이스의 대안 클래스들
  - 데이터 클래스
    - 데이터 필드와 게터/세터로만 구성된 클래스
  - 상속 포기
  - 주석
    - 주석을 달지 말라는건 아니지만, 장황하게 달린 코드는 잘못 작성된 경우가 많다.

4. 테스트 구축하기
5. 리팩터링 카탈로그 보는 법
6. 기본적인 리팩터링
7. 캡슐화
8. 기능 이동
9. 데이터 조직화
10. 조건부 로직 간소화
11. API 리팩터링
12. 상속 다루기