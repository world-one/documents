### 인사이트 자바스크립트
#### 자바스크립트 데이터 타입과 연산자
#### 함수와 프로토타입 체이닝
- 함수 정의
  - 함수 선언문
  - 함수 표현식
  - 생성자 함수
- 일급 객체(First Class)
  - 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
  - 함수의 인자로 전달 가능
  - 함수의 리턴값으로 리턴 가능
  - 동적으로 프로퍼티 생성 및 할당 가능
- prototype 프로퍼티
  - 모든 함수는 객체로서 prototype 프로퍼티를 가지고 있다.
  - 객체의 부모를 나타내는 내부 프로퍼티인 [[Prototype]]과 혼동하지 말아야한다.
  - 함수가 생성될 때 만들어지며 prototype 객체도 함께 생성하여 연결된다. constructor 프로퍼티 하나만 있는 객체를 가리킨다. 
    - constructor
    - `__proto__`
- 함수 호출과 this
  - arguments 객체: 함수 호출시 인자값과 함께 암묵적으로 전달된다. 유사 배열 객체
  - this: 호출 패턴에 따라 this가 다른 객체를 참조한다.
#### 실행 컨텍스트
- 실행 컨텍스트는 콜 스택에 들어가는 실행 정보 하나와 비슷하다.
    - 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이다.
    - 콜스택과 연관하여 정의하면 실행 가능한 자바스크립트 코드 블록이 실행되는 환경이다.
    - 코드 블록은 대부분의 경우 함수를 말한다.
    - 실행 컨텍스트가 형성되는 경우는 아래와 같다.
        - 전역 코드
        - eval() 함수로 실행되는 코드
        - 함수 안의 코드를 실행할 경우
    - 코드 블록 안에는 변수 및 객체, 실행 가능한 코드가 들어 있다. 이 코드가 실행되면 실행 컨텍스트가 생성되고, 이는 스택 안에 하나씩 차곡차곡 쌓이고, 제일 위에 있는 실행 컨텍스트가 현재 실행되고 있는 컨텍스트이다.
- 현재 실행되는 컨텍스트에서 이 컨텍스트와 관련 없는 실행 코드가 실행되면, 새로운 컨텍스트가 생성되어 스택에 들어가고 제어권이 그 컨텍스트로 이동한다.
- 생성 과정
    - 활성 객체 생성
        - 실행 컨텍스트가 생성되면 실행에 필요한 여러가지 정보를 담을 객체를 생성하는데 이를 활성 객체라고 한다. 앞으로 사용하게 될 매개변수나 사용자가 정의한 변수 및 객체를 저장하고 엔진에서 접근 가능하게 된다.
    - arguments 객체 생성
    - 스코프 정보 생성
        - 현재 컨텍스트의 유효 범위를 나타내는 스코프 정보를 생성
        - 현재 실행 중인 실행 컨테스트 안에서 연결 리스트와 유사한 형식으로 만들어진다. 특정 변수에 접근해야 할 경우 이 리스트를 활용, 상위 컨텍스트의 변수도 접근이 가능하다.
    - 변수 생성
    - this 바인딩
        - 메서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩된다.
        ```
          // 객체의 프로퍼티가 함수일 경우 메서드라고 부른다.
          const myObject = {
              name: 'foo',
              sayName: function () {
                  console.log(this.name);
              }
          };
          const otherObject = {
              name: 'bar'
          }
          otherObject.sayName = myObject.sayName;
          myObject.sayName(); //foo
          otherObject.sayName(); //bar
        ```
        - 함수 호출시 this 바인딩
          - this는 전역 객체에 바인딩되면 브라우저는 window 객체, node는 global 객체
          - 내부 함수 호출시 호출 패턴 규칙에 따라 this는 전역 객체에 바인딩된다.
            - that이라는 변수에 this를 할당해서 사용하는 방법으로 해결하거나 call, apply, bind 사용
        - 생성자 함수를 호출할 때 this 바인딩
          - 기존 함수에 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다.
            - 보통 파스칼 케이스로 사용 권장
          - 생성자 함수 동작 방식
            - 빈 객체 생성 및 this 바인딩
              - 엄밀히 말하면 빈 객체는 아니며 부모의 프로토타입 객체와 연결되어 있다.
            - this를 통한 프로퍼티 생성
            - 생성된 객체 리턴
              - 리턴문이 없을 경우 this로 바인딩된 새로 생성한 객체가 리턴된다.
        - 객체 리터럴 방식과 생성자 함수를 통한 객체 생성 방식의 차이
          - 객체 리터럴 방식으로 생성된 객체는 같은 형태의 객체를 재생성할 수 없다.
          - 생성자 함수는 호출할 때 다른 인자를 넘겨 같은 형태의 서로 다른 객체를 생성할 수 있다.
          - 프로토 타입 객체가 객체 리터럴 방식은 Object를 가리키고 생성자 함수는 생성자 함수의 prototype을 가리킨다.
          - new를 사용하지 않고 호출할 경우 에러가 발생할 수 있어서 인스턴스를 생성하는 별도의 코드 패턴을 사용한다.
        - call, apply를 이용한 명시적인 this 바인딩
#### 프로토타입 체이닝
- 프로토타입 기반의 객체지향 프로그래밍
- 자신의 부모인 프로토타입 객체를 가리키는 참조 링크 형태의 숨겨진 프로퍼티가 있다. ECMAScript에서는 이러한 링크를 암묵적 프로토타입 링크라고 부르며 [[Prototype]] 프로퍼티에 저장된다.
- 프로토타입 체이닝
  - 자바스크립트에서 특정 객체의 프로퍼티나 메서드에 접근하려고 할 때, 해당 객체에 프로퍼티 또는 메서드가 없다면 [[Prototype]] 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티를 차례대로 검색하는 것을 말한다.
- 프로토타입 체이닝의 종점
  - 모든 자바스크립트 객체는 프로토타입 체이닝으로 Object.prototype 객체가 가진 프로퍼티와 메서드에 접근하고, 서로 공유가 가능하다는 것을 알 수 있다.
- 객체의 프로퍼티 읽기나 메서드를 실행할 때만 프로토타입 체이닝이 동작한다.