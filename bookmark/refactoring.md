### Refactoring
겉으로 드러나는 기능은 바꾸지 않으면서 내부 구조를 개선하는 것   
즉, 코드 작성 후 설계 개선

1. 리팩터링 : 첫 번째 예시
   - 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다. 
   - 리팩터링으로 인한 성능 문제는 특별한 경우가 아니라면 일단 무시하라. 리팩터링 때문에 성능이 떨어진다면, 이후에 개선하자.
   - 함수를 변수에 담아 사용하기 보다는 함수 자체를 인라인으로 쓰는 것을 권장함.
   - 단계를 엄청 잘게 쪼개서 해당 단계를 마치면 컴파일-테스트-커밋을 진행..
   - 도착했을 때보다 깔끔하게 정돈하고 떠난다.
   - 리팩터링을 하고 난 후 코드가 명확해지 이해하기 더 쉬워진다.
   - 얼마나 수정하기 쉬운가가 좋은 코드를 가늠하는 기준이 된다.
2. 리팩터링 원칙
   -  정의 
      - (명사)겉보기 동작은 그대로 유지하며 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
      - (동사)겉보기 동작은 그대로 유지하며, 여러가지 리팩터링 기법을 적용하여 소프트웨어를 재구성하다.
   - 동작을 보존하는 작은 단계들을 거치며 코드를 정리하는 것 
   - 두개의 모자
      - 기능 추가시에는 기존 코드를 건드리지 않고 새 기능을 추가한다.
      - 리팩터링시에는 코드 재구성만 한다.
   - 해야하는 이유
     - 소프트웨어 설계가 좋아진다.
     - 소프트웨어를 이해하기 쉬워진다.
     - 버그를 쉽게 찾을 수 있다.
     - 프로그래밍 속도를 높일 수 있다.
   - 언제 해야 할까?
      - 3의 법칙
        - 그냥 하다가 두번째 중복까지는 진행, 세번째엔 리팩터링
      - 준비를 위한 - 기능 쉽게 추가하도록
      - 이해를 위한 - 코드를 이해하기 쉽도록
      - 쓰레기 줍기 - 시간을 많이 쓰고 싶지 않다면 조금이라도
      - 계획된 리팩터링, 수시 리팩터링
      - 오래 걸리는 리팩터링
      - 코드 리뷰
      - 하지말아야 할 때(판단력과 경험이 중요하다.)
        - 내부 동작을 이해하지 못 할 때
        - 처음부터 작성하는게 쉬울 경우 
   - 고려할 문제
      - 새 기능 개발 속도 저하
        - 코드 베이스를 예쁘게 하는게 아닌 경제적인 이유로 하는 것이다. 개발 기간, 기능 추가 시간, 버그 수정시간 단축 등
      - 코드 소유권
        - 코드 소유권을 느슨하게 하여 담당자가 아니어도 수정이 가능하도록
      - 브랜치
        - 지속적 통합(Continue Integration)
        - 트렁크 기반 개발(Trunk-Based Development)
      - 테스팅
      - 레거시 코드
      - 데이터베이스
    - 리팩터링, 아키텍처, 애그니(YAGNI) 
      - 간결한 설계, 점진적 설계, you aren`t going to need it
      - 그냥 현재까지 파악한 요구사항을 멋지게 해결하도록 한다.
    - 리팩터링과 소프트웨어 개발 프로세스
      - TDD
    - 성능
      - 리팩터링 단계에서는 성능을 고려하진 않아서 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하는 것이 쉬워진다.
    - 리팩터링의 유래
      - 워드 커닝햄, 켄트 백, 랄프 존스, 빌 옵다이크, 존 브랜트, 돈 로버츠 
    - 리팩터링 자동화
      - 인텔리 제이, 이클립스 등 자동 리팩터리을 지원하는 도구
      - 소스 코드의 텍스트를 직접 조작하는 방법은 어설프지만, 첫 발을 내딛는 데는 유용하다.
      - 리팩터링 도구들은 안전하지만 간혹 문제를 일으킨다. 그래서 자동와 수동을 적절히 함께 사용해주면 테스트도 충분히 거친다.
      - 언어 서버, language server
    - 더 알고 싶다면
      - 윌리엄 웨이크의 리팩터링 워크북
      - 조슈아 케리에프스카의 패턴을 활용한 리팩터링
      - 스캇 엠블러와 프라모드 사달게의 리팩토링 데이터베이스
      - 엘리엇 러스티 해롤드의 리팩토링 html
      - 마이클 페더스의 레거시 코드 활용 전략
      - https://github.com/WegraLee/Refactoring
      - https://www.refactoring.com/
3. 코드에서 나는 악취
  - 기이한 이름
  - 중복 코드
  - 긴 함수
    - 적절한 이름으로 함수 쪼개기
    - 주석을 달아야 할 부분은 함수로 만들기
    - 의도가 드러나는 이름
    - 성격이 다른 작업이 섞여 있다면 분리
  - 긴 매개변수 목록
  - 전역 데이터
  - 가변 데이터
  - 뒤엉킨 변경
    - 단일 책임 원칙이 제대로 지켜지지 않을 때
  - 산탄총 수술
    - 코드 수정 시 자잘하게 수정해야하는 곳이 많을 때
  - 기능 편애
    - 함께 변경할 대상을 한데 모으는 것
  - 데이터 뭉치
    - 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야한다.
  - 기본형 집착(기본 타입에 대한 강박관념)
    - 문제에 맞는 기초형 타입을 직접 정의하는 것?
  - 반복되는 switch문
    - 조건부 로직을 다형성으로 바꾸기
  - 반복문
    - 반복문을 파이프라인으로 바꾸기
  - 성의 없는 요소
    - 역할이 줄어든 프로그램 요소는 제거작업 진행
  - 추측성 일반화
    - 미래를 대비해 작성한(사용되지 않는) 부분은 쓸데없는 낭비이니 제거하자
  - 임시 필드
    - 특정 상황에서만 값이 설정되는 필드에 대한 처리
  - 메시지 체인
    - 위임 숨기기
      ```
      aPerson.department.manageName
      aPerson.manage.name
      aPerson.manageName
      ```
  - 중개자
  - 내부자 거래
    - 결합도가 높을 때, 데이터 거래를 줄이고 투명하게 처리해야 한다.
  - 거대한 클래스
  - 서로 다른 인터페이스의 대안 클래스들
  - 데이터 클래스
    - 데이터 필드와 게터/세터로만 구성된 클래스
  - 상속 포기
  - 주석
    - 주석을 달지 말라는건 아니지만, 장황하게 달린 코드는 잘못 작성된 경우가 많다.

4. 테스트 구축하기
  - 자가 테스트 코드의 가치
    - 모든 테스트의 완전 자동화와 결과 검사까지 하도록
    - 회귀 버그, 회귀 테스트
    - 테스트 주도 개발(TDD) 
      - 테스트 - 코딩 - 리팩터링
    - 테스트 프레임워크 - 책에서는 mocha 사용
    - 테스트 추가하기
      - 위험 요인 중심으로, 너무 많이 만들지 않도록 하자(불피룡한 부분)
      - 테스트끼리 상호 작용하는 공유 픽스터를 생성하지 않도록 한다.
    - 픽스처 수정
      - 테스트 패턴, 설정 - 실행 - 검증 / 조건 - 발생 - 결과 / 준비 - 수행 - 단언
    - 경계 조건 검사
      - happy path를 벗어나는 경계 지점에서 문제가 생길 경우
      - 문제가 생길 가능성이 있는 경계 조건을 생각하고 집중적으로 테스트
    - 끝나지 않은 여정
      - 버그 리포트를 받으면 그 버그의 단위 테스트부터 작성하자.

5. 리팩터링 카탈로그 보는 법
  - 리팩터링 설명 형식
    - 이름
    - 개요
    - 배경
    - 절차
    - 예시
  - 리팩터링 기법 선정 기준
    - 유용함, 간단하고 직관적인 건 생략
6. 기본적인 리팩터링
  - 함수 추출하기(extract function)
    - 목적과 구현을 분리
    - 함수의 이름이 구현 코드가 길어도 문제가 되지 않는다.
    - 짧은 함수들이 많아져 호출이 늘어날 경우 성능에 대한 문제는 걱정하지 말자
      - 컴파일러가 짧은 함수들을 쉽게 캐싱하여 최적화하는데 유리할 때도 있다.
    - 성능 최적화, 하지마라... 아직 하지마라...
    - 절차
      - 함수를 만들고 목적을 드러내는 이름을 붙인다.
      - 추출할 코드를 원본에서 복사하여 새 함수에 넣는다.       
      - 지역 변수를 참조하거나 유효범위를 벗어나는 변수는 없는지 검사하여 매개변수로 전달한다.
      - 변수를 다 처리했다면 컴파일한다.
      - 원본 함수에서 추출한 코드 부분을 함수를 호출하는 문장으로 바꾼다.
      - 테스트
      - 다른 코드에 똑같거나 비슷한 곳이 있는지 확인후 수정
  - 함수 인라인하기(Inline Function)
    - 함수 본문이 이름만큼 명확한 경우는 함수를 제거한다.
    - 절차
      - 다형 메서드인지 확인
      - 인라인할 함수를 호출하는 곳을 찾는다.
      - 호출문을 본문으로 교체
      - 교체시 마다 테스트
      - 원래 함수를 제거
    - 단계를 잘게 나눠서 처리하자
  - 변수 추출하기(Extract Variable)
    - 표현식이 복잡해서 이해하기 어려울 경우 지역 변수를 활용하면 쪼개서 관리하기 쉽다.
    - 단계마다 이름을 붙여 코드의 목적 더 명확해 진다.
    - class 객체를 이용한 장점은 특정 로직과 데이터를 외부와 공유하려 할 때 이를 설명해주는 적당한 크기의 문맥이 되어준다.
  - 변수 인라인하기(Inline Variable)
    - 변수와 원래의 표현식이 다를 바 없을 경우 인라인 하는 것이 좋다.
  - 함수 선언 바꾸기
    - 함수의 이름
    - 간단한 절차와 마이그레이션 절차
    - 매개 변수 추가하기
    - 매개 변수를 속성으로 바꾸기
  - 변수 캡슐화하기(Encapsulate variable)
    - 데이터를 변경하고 사용하는 코드를 감시할 수 있다.
    - 절차
      - 변수 접근과 갱신을 전담하는 캡슐화 함수를 만든다.
      - 정적 검사
      - 변수 직접 참조하는 부분을 캡슐화 함수 호출로 변경
      - 변수의 접근 범위를 제한
  - 변수 이름 바꾸기(Rename Variable)
  - 매개변수 객체 만들기(Introduce Parameter Object)
  - 여러 함수를 클래스로 묶기(Combine Functions into Class)
    - 클래스로 묶을 때의 장점은 클라이언트가 객체의 핵심 데이터를 변경할 수 있고, 파생 객체들을 일관되게 관리할 수 있다.
    - 중첩 함수 형태로 묶을 수도 있지만 테스트가 까다로울 수 있다.
    - 절차
      - 함수들이 공유하는 공통 데이터 레코드 캡슐화
      - 공통 레코드를 사용하는 함수를 클래스로 이동
      - 데이터 조작 로직은 함수로 추출해서 새 클래스로 이동  
  - 여러 함수를 변환 함수로 묶기(Combine Functions into Transform)
    - 같은 로직이 반복되는 것들은 한곳에 모아두면 검색과 갱신을 일관된 장소에서 처리할 수 있고 로직 중복도 막을 수 있다.
    - 데이터의 일관성이 깨질 수 있어서, 자바스크립트에서는 이 문제를 해결하기 위해서 클래스로 묶기가 좋은 방법으로 보인다.
    - 불변 데이터 구조를 지원하는 언어는 이런 문제가 생길 일이 없어서 변환 함수로 묶기를 사용하는 비중이 높다.
  - 6.11 단계 쪼개기(Split Phase)
    - 다른 단계로 볼 수 있는 코드 영역들이 서로 다른 데이터와 함수를 사용한다면 단계 쪼개기에 적합하다.
    - 테스트를 쉽게 수행할 수 있도록 수정한 다음에 리팩토링하는게 좋다.
    - 험블 객체 패턴: 명령문 호출과 표준 출력에 쓰는 느리고 불편한 작업과 자주 테스트 해야 할 복잡한 동작을 분리
    - 첫번째 단계에서 객체를 변환기로 사용하기
7. 캡슐화
  -  모듈 분리의 가장 중요한 기준은 각 모듈이 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐에 있다.
  - 7.1 레코드 캡슐화하기 (Encapsulate Record)
    - 중첩된 리스트나 해시맵을 캡슐화하면 포맷을 바꾸거나 추적하기 어려운 데이터를 수정하기 수월해진다.
    - 레코드를 캡슐화하는 목적은 변수 자체는 물론 그 내용을 조작하는 방식도 통제하기 위해서다.
  - 7.2 컬렉션 캡슐화하기 (Encapsulate Collection)
    - 컬렉션에 대해서는 강박증을 가지고 복제본을 만드는 편이 예상치 못한 수정이 촉발한 오류를 디버깅하는 것보다 낫다. 
  - 7.3 기본형을 객체로 바꾸기 (Replace Primitive with Object)
    - 직관에 어긋나고, 대단해 보이지 않을 수 있지만 코드베이스에 미치는 효과는 놀라울 만큼 크다.
  - 7.4 임시 변수를 질의 함수로 바꾸기 (Replace Temp with Query)
    - 변수에 값을 한 번 대입한 뒤 더 복잡한 코드 덩어리에서 여러 차례 다시 대입하는 경우는 모두 질의 함수로 추출해야 한다.
  - 7.5 클래스 추출하기 (Extract Class)
    - 클래스는 명확하게 추상화하고 소수의 주어진 역할만 처리해야 한다.
  - 7.6 클래스 인라인하기 (Inline Class)
    - 남는 역할이 거의 없을 때 가장 많이 사용하는 클래스에 흡수
    - 두 클래스의 기능을 재분배할 때
  - 7.7 위임 숨기기 (Hide Delegate)
    - 모듈화 설계의 핵심은 캡슐화이다. 이를 잘해 둔다면 변경 시 고려해야 할 모듈 수가 적어진다.
  - 7.8 중개자 제거하기 (Remove Middle Man)
    - 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 위임 메서드를 추가해야하는데 그러다 보면 단순히 전달만 하는 위임 메서드들이 점점 늘어나게 된다.
    - 위임 숨기기나 중개자 제거하기는 상황에 맞게 처리하면 된다.  
  - 7.9 알고리즘 교체하기 (Substitute Algorithm)
    - 복잡한 것을 간결하게 고친다.
8. 기능 이동
  - 8.1 함수 옮기기 (Move Function)
    - 모듈성 : 프로그램의 어딘가를 수정하려 할 때 해당 기능과 갚이 관려된 작은 일부만 이해해도 가능하게 해주는 것
    - 모듈성을 높이기 위해서는 서로 연관된 요소들을 함께 묶고, 요소 사이의 연결 관계를 쉽게 찾고 이해할 수 있도록 해야 한다.
  - 8.2 필드 옮기기 (Move Field)
    - 주어진 문제에 적합한 데이터 구조를 활용하면 동작 코드는 자연스럽게 단순하고 직관적으로 짜여진다.
    - 함수에 어떤 레코드를 넘길 때마다 또 다른 레코드의 필드도 함께 넘기고 있다면 데이터 위치를 옮겨야 할 것이다.
    - 한 레코드를 변경하려 할 때 다른 레코드의 필드까지 변경해햐만 한다면 필드의 위치가 잘못되었다는 신호다.
  - 8.3 문장을 함수로 옮기기 (Move Statements into Function)
  - 8.4 문장을 호출한 곳으로 옮기기 (Move Statements to Callers)
  - 8.5 인라인 코드를 함수 호출로 바꾸기 (Replace Inline Code with Function Call)
  - 8.6 문장 슬라이드하기 (Slide Statements)
    - 관련된 코드들이 가까이 모여 있다면 이해하기가 더 쉽다.
  - 8.7 반복문 쪼개기 (Split Loop)
    - 반복문 하나에서 두 가지 일을 할 경우 분리한다. 
    - 반복문을 두 번 실행해야하는 것에 불편함을 느끼지 말고 리팩터링과 최적화를 구분하도록 한다.
  - 8.8 반복문을 파이프라인으로 바꾸기 (Replace Loop with Pipeline)
    - filter나 map 같은 컬렉션 파이프라인을 사용하자. 논리를 파이프라인으로 표현하면 이해하기 훨씬 쉬워진다.
  - 8.9 죽은 코드 제거하기 (Remove Dead Code)
9. 데이터 조직화
  - 9.1 변수 쪼개기 (Split Variable)
    - 변수에는 값을 한 번만 대입해야 하며, 두 번 이상 이뤄진다면 여러 가지 역할을 수행한다는 신호다. 역할이 둘 이상인 변수가 있다면 쪼개야 한다.
  - 9.2 필드 이름 바꾸기 (Rename Field)
  - 9.3 파생 변수를 질의 함수로 바꾸기 (Replace Derived Variable with Query)
  - 9.4 참조를 값으로 바꾸기 (Change Reference to Value)
    - 참조: 내부 객체는 그대로 둔 채 그 객체의 속성만 갱신
    - 값: 새로운 속성을 담은 객체로 기존 내부 객체를 통채로 대체
    - 특정 객체를 여러 객체에서 공유할 경우는 이 리팩터링을 진행하면 안된다.
  - 9.5 값을 참조로 바꾸기 (Change Value to Reference)
    - 데이터 갱신시 일관성을 위해 참조로 변경
  - 9.6 매직 리터럴 바꾸기 (Replace Magic Literal)
    - 리터럴 값들을 의미를 알 수 있게 상수로 선언한다.
10. 조건부 로직 간소화
  - 10.1 조건문 분해하기 (Decompose Conditional)
    - 조건식과 그 조건식에 딸린 조건절 각각을 함수로 추출한다.
    - 취향에 따라 3항 연산자로 바꿔준다.
  - 10.2 조건식 통합하기 (Consolidate Conditional Expression)
    - 결과로 수행하는 동작은 똑같은 코드들은 하나로 통합한다.
    - 진짜 독립된 검사라면 하지 않는다.
  - 10.3 중첩 조건문을 보호 구문으로 바꾸기 (Replace Nested Conditional with Guard Clauses)
  - 10.4 조건부 로직을 다형성으로 바꾸기 (Replace Conditional with Polymorphism)
    - 클래스와 다형성을 이용한 분리
    - 변형 동작을 다형성으로 표현하기
  - 10.5 특이 케이스 추가하기 (Introduce Special Case)
  - 10.6 어서션 추가하기 (Introduce Assertion)
    - 특정 조건에 대한 가정을 알아낼 수 있도록 어서션을 이용해서 코드 자체에 삽입한다.
    - 어서션은 항상 참이라고 가정하는 조건부 문장이다.
  - 10.7 제어 플래그를 탈출문으로 바꾸기 (Replace Control Flag with Break)
    - 제어 플래그: 코드의 동작을 변경하는 데 사용되는 변수
11. API 리팩터링
  - 11.1 질의 함수와 변경 함수 분리하기 (Separate Query form Modifier)
    - 상태를 변경하는 부분과 질의하는 부분을 분리
  - 11.2 함수 매개변수화하기 (Parameterize Function)
    - 다른 값만 매개변수로 받아 처리하는 함수로 만들기
  - 11.3 플래그 인수 제거하기 (Remove Flag Argument)
    - 플래그 인수가 있으면 함수의 기능 차이가 잘 드러나지 않는다.
    - 매개변수로 주어지는 값 각각에 대응하는 명시적 함수들을 생성한다.
    - 매개변수의 사용이 까다로운 방식일 경우, 일이 커질 수도 있어서 해당 함수를 감싸는 방식으로 사용하는 방법도 있다.
  - 11.4 객체 통째로 넘기기 (Preserve Whole Object)
    - 하나의 레코드에서 값을 여러개 가져와 인수로 넘기는 경우 레코드를 통채로 넘기도록 수정
    - 변화에 대응하기 쉽다.
    - 매개변수 목록이 짧아져 사용법을 이해하기 쉬워진다.
  - 11.5 매개변수를 질의 함수로 바꾸기 (Replace Parameter with Query)
  - 11.6 질의 함수를 매개변수로 바꾸기 (Replace Query with Parameter)
    - 전역 변수를 참조하거나 제거하길 원하는 원소를 참조하는 경우는 매개 변수로 바꿔 해결
    - 특정 원소에 의존하길 원치 않을 때
    - 참조 투명성: 똑같은 값을 넘기면 똑같은 결과가 나온다.
    - 호출자는 전보다 다루기 어려워지는 게 보통이며, 결합도를 낮춘 효과의 반대급부라고 볼 수 있다.
  - 11.7 세터 제거하기 (Remove Setting Method)
    - setter를 제거하여 의도를 명확히 전달
    - 필요한 상황
      - 접근자 메서드를 통해서만 필드를 다루려 할 때
      - 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때
  - 11.8 생성자를 팩터리 함수로 바꾸기 (Replace Constructor with Factory Function)
    - 생성자에는 일반 함수에는 없는 이상한 제약이 따라붙는다. 팩터리 함수에는 제약이 없다.
  - 11.9 함수를 명령으로 바꾸기 (Replace Function with Command)
    - 함수를 그 함수만을 위한 객체 안으로 캡슐화하면 더 유용해지는 상황이 있으며, 이런 객체를 명령 객체 또는 명령(Command)라고 한다.
    - 자바스크립트는 중첩 함수가 명령의 대안이 될 수 있지만, 명령을 사용하면 서브함수들을 테스트와 디버깅에 활용할 수 있다.
  - 11.10 명령을 함수로 바꾸기 (Replace Command with Function)
    - 로직이 크게 복잡하지 않다면 명령 객체는 장점보다 단점이 크니 평범한 함수로 바꿔주는 것이 낫다.
  - 11.11 수정된 값 반환하기 (Return Modified Value)
    - 데이터가 수정되는 사실을 명확히 알려줘서 어느 함수가 무슨 일을 하는지 쉽게 알 수 있도록 하는 일은 매우 중요하다.
  - 11.12 오류 코드를 예외로 바꾸기 (Replace Error Code with Exception)
    - 예외는 프로그램의 정상 동작 범주에 들지 않는 오류를 나타낼 때만 쓰여야 한다.
  - 11.13 예외를 사전확인으로 바꾸기 (Replace Exception with Precheck)
    - 예외는 뜻밖의 오류라는 말 그대로 예외적으로 동작할 때만 쓰여야 한다. 함수 수행 시 문제가 될 수 있는 조건을 함수 호출 전에 검사할 수 있다면, 예외 대신 호출하는 곳에서 조건을 검사하도록 한다.
12. 상속 다루기
  - 12.1 메서드 올리기 (Pull Up Method)
    - 똑같이 동작하는 메서드는 슈퍼클래스에 새로운 메서드를 생성하고 대상의 코드를 복사해넣는다.
  - 12.2 필드 올리기 (Pull Up Field)
  - 12.3 생성자 본문 올리기 (Pull Up Constructor Body)
    - 공통 코드를 슈퍼클래스에 추가
  - 12.4 메서드 내리기 (Push Down Method)
    - 특정 서브클래스만 관련 있을 경우 슈퍼클래스에서 제거 후 해당 서브 클래스에 추가
  - 12.5 필드 내리기 (Push Down Field)
  - 12.6 타입 코드를 서브클래스로 바꾸기 (Replace Type Code with Subclasses)
    - 서브클래스의 두 가지 장점
      - 조건에 따라 다르게 동작하도록 해주는 다형성
      - 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때
  - 12.7 서브클래스 제거하기 (Remove Subclass)
    - 더 이상 쓰이지 않는 서브클래스는 슈퍼클래스의 필드로 대체해 제거
  - 12.8 슈퍼클래스 추출하기 (Extract Superclass)
    - 비슷한 일을 수행하는 두 클래스가 보이면 상속을 이용해 비슷한 부분을 슈퍼클래스로 옮겨 담는다.
  - 12.9 계층 합치기 (Collapse Hierarchy)
    - 클래스 계층구조가 진화하면서 그 부모와 너무 비슷해질 경우 그 둘을 하나로 합쳐야 한다.
  - 12.10 서브클래스를 위임으로 바꾸기 (Replace Subclass with Delegate)
    - 상속의 가장 명확한 단점은 한 번만 쓸 수 있다는 것이다. 달라져야 하는 이유가 여러 개여도 상속에서는 그 중 단 하나의 이뮤나 선택해 기준으로 삼을 수 밖에 없다. 또한 상속은 클래스들의 관계를 아주 긴밀하게 결합한다.
    - 위임은 다양한 클래스에 서로 다른 이유로 위임할 수 있다.
    - 위임은 객체 사이의 일반적인 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의 할 수 있다.
    - '상속 보다는 객체 컴포지션을 사용하라', 상속을 쓰지 말라는 게 아닌 과용하지 말라.
      - 적절히 혼용하라.
  - 12.11 슈퍼클래스를 위임으로 바꾸기 (Replace Superclass with Delegate)
    - 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이지만 혼란과 복잡도를 키우기도 한다.
    - 상속을 먼저하고 나중에 문제가 생기면 슈퍼클래스를 위임으로 바꾸기


  나중에 다시 읽으며, 내용을 정리해보자.


