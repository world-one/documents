### 1. 설계와 아키텍쳐란?
- 보통의 의미
  - 설계: 저수준이 구소 또는 결정사항 등
  - 아키텍처: 고수준의 무언가
- 저수준의 세부사항과 고수준의 결정사항은 전체 설계의 구성 요소가 된다. 둘을 구분 짓는 경계는 뚜렷하지 않다. 고수준에서 저수준으로 향하는 의사결정의 연속성만 있다.
- 목표
  - 시스템을 만들고 유지보수하는데 투입되는 인력의 최소화
- 빨리 가는 유일한 방법은 제대로 가는 것이다.
### 2. 두 가지 가치에 대한 이야기
- 아키텍처는 형태에 독립적이어야하고 그럴수록 실용적이다.
- 기능의 긴급성, 아키텍처의 중요성


## 프로그래밍 패러다임
### 3. 패러다임 개요
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 각 패러다임은 무엇을 해야 하는지보다는 무엇을 하면 안되는지를 말해준다.
### 4. 구조적 프로그래밍
- 증명
  - 순차, 분기, 반복
- 기능적 분해
  - 고수준의 기능 분해 -> 저수준의 함수들로 분해
  - 구조적 분석, 구조적 설계
- 테스트: 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여준다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록 만들기 위해 노력해야한다.
### 5. 객체 지향 프로그래밍
- OO란 무엇일까?
  - 데이터와 함수의 조합?
  - 실제 세계를 모델링하는 새로운 방법?
  - 캡슐화, 상속, 다형성?
- 캡슐화
  - OO 언어에서 제공
  - 응집력 있는 집단을 구분 짓는 선
  - 데이터 은닉, 일부 함수만 외부에 노출
  - OO 언어들은 C 언어에서 누렸던 완벽한 캡슐화를 약화시켜 왔다.
- 상속
  - OO 언어가 새로운 개념을 만들진 못했지만 편리한 방식을 제공했다.
- 다형성
  - OO 언어는 다형성을 좀 더 안전하고 편리하게 사용할 수 있게 해준다.
- 의존성 역전
  - 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.
  - 배포 독립성
  - 개발 독립성
- 그래서 OO 란?
  - 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력
### 6. 함수형 프로그래밍
- 기반은 람다 계산법
- 리스프에서 파생된 클로저
- 자바는 가변 변수를 사용, 클로저는 가변 변수가 없다.
- 불변성과 아키텍쳐
  - 경합 조건, 교착 상태 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생
  - 불변성을 실현하기 위해서는 타협이 필요
- 가변성의 분리
  - 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.
- 이벤트 소싱
  - 상태가 아닌 트랜잭션을 저장하는 전략이다.
  - CRUD에서 CR만 수행한다.
  - 저장 공간과 처리 능력이 충분하면 완전한 불변성을 갖도록 만들 수 있고 완전한 함수형으로 만들 수 있다.
  - 소스 코드 버전 관리 시스템이 이런 방식으로 동작한다.

## 설계 원칙
- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 곳에 사용될 수 있는 컴포넌트의 기반이 된다.
### 7. SRP: 단일 책임 원칙
- 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.
- 원칙을 위반하는 징후
  - 우발적 중복: 서로 다른 액터가 의존하는 코드를 너무 가까이 배치해서 문제 발생
  - 병합
  - 해결책
    - 메서드를 각기 다른 클래스로 이동
    - 데이터와 메서드를 분리하는 방식
- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 상위의 수준에서도 다른 형태로 나타난다. 
### 8. OCP: 개방-폐쇄 원칙
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 시스템을 확장하기 쉬우면서 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 한다.
  - 시스템을 컴포넌트 단위로 분리하고 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.
### 9. LSP: 리스코프 치환 원칙
- 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모
- 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 별도의 메커니즘을 추가해야 한다.
### 10. ISP: 인터페이스 분리 원칙
- ISP는 아키텍처가 아니라 언어와 관련된 문제라고 볼 수 있다.
  - 정적 타입 언어는 import, use와 같이 타입 선언문을 사용하도록 강제하여 의존성이 발생한다.
  - 루비나 파이썬과 같은 동적 타입 언어는 선언문이 존재하지 않으며 런타임에 추론이 발생한다. 즉 의존성이 없다.
- 필요 이상을 포함하는 모듈에 의존하는 것은 해롭다. 불필요한 재컴파일과 재배포를 강제하기 때문이다.
  - S -> F -> D와 같이 의존을 할때 D를 수정하면 F와 S까지 모두 재배포해야한다.
### 11. DIP: 의존성 역전 원칙
- 유연성이 극대화된 시스템: 소스 코드 의존성이 추상에 의존하며 구체에 의존하지 않는 시스템
- 이 규칙은 비현실적이다. 안정석이 보장된 환경에 대해서는 무시하는 편
  - 변동성이 큰 구체적인 요소는 피해야한다.
- 안정된 추상화
  - 변동성이 큰 구체 클래스를 참조하지 말라
  - 변동성이 큰 구체 클래스로부터 파생하지 말라
  - 구체 함수를 오버라이드 하지말라
  - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
- 팩토리
  - 바람직하지 못한 의존성을 처리할 때 추상 팩토리 사용 

## 컴포넌트 원칙
### 12. 컴포넌트
- 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
- 링커
  - 링킹 로더의 등장으로 프로그램을 개별적으로 컴파일하고 로드할 수 있는 단위로 분할할 수 있게 되었다.
- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트다.
### 13. 컴포넌트 응집도
- REP: 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)
    - 재사용 단위는 릴리스 단위와 같다.
    - 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 보증할 방법이 전혀 없다.
    - 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다.
- CCP: 공통 폐쇄 원칙(Common Closure Principle)
  - 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라, 그렇지 않으면 분리하라.
  - SRP의 컴포넌트 관점
- CRP: 공통 재사용 원칙(Common Reuse Principle)
  - 컴포넌트 사용자들을 필요하지 않는 것에 의존하도록 강요하지 말라.
  - 어떤 클래스를 한 곳에 묶어둬야하는지, 아니면 동일한 컴포넌트에 두면 안되는지.
- 응집도의 세 원칙은 서로 상충된다.
  - REP, CCP는 포함 원칙, CRP는 배제 원칙
  - REP, CRP에 중점을 두면 사소한 변경이 많은 컴포넌트에 영향을 준다.
  - CCP, CRP에 중점을 두면 재사용이 어렵다.
  - REP, CCP에 중점을 두면 불필요한 릴리스가 많아진다.
- 세 원칙의 균형점은 항상 유동적이다.
### 14. 컴포넌트 결합
- ADP: 의존성 비순환 원칙
  - 컴포넌트 의존성 그래프 순환이 있어서는 안된다.
  - 주단위 빌드: 4일은 각자 개발 후 하루에 통합하여 시스템 빌드
    - 이는 프로젝트가 점점 커질 때마다 통합에 드는 시간이 증가한다.
  - 위 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것
    - 통합은 작고 점진적으로 이뤄진다.
  - 순환 끊기
    1. 의존성 역전 원칙(DIP)
    2. 새롭게 의존하는 컴포넌트를 만든다.
        - 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다. 의존성 구조는 서서히 흐트러지며 성장한다.
  - 하향식 설계
    - 컴포넌트 구조는 하향식으로 설계될 수 없다.     
- SDP: 안정된 의존성 원칙
  - 안정성의 방향으로(더 안정된 족에) 의존하라.
  - 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들면 안된다.
  - 안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다.
  - 안정성은 변경을 만들기 위해 필요한 작업량과 관련된다.
    - 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이다. 변경에 많은 노력이 들기 때문이다.
    - 의존하는 컴포넌트가 많으면 불안정하며, 의존하는 수만큼 변경의 이유가 늘어난다.
  - 안정성 지표
    - 의존성의 개수
      - Fan-in: 안으로 들어오는 의존성.
      - Fan-out: 바깥으로 나가는 의존성.
      - I(불안정성) = Fan-out / (Fan-in + Fan-out) 
        - 0~1 사이의 값을 가지며, I = 0 일 경우 최고로 안정된 컴포넌트이다.
          - 다른 컴포넌트를 책임지며, 또 독립적이다.
        - I 값이 1이면 어떤 컴포넌트도 해당 컴포넌트에 의존하지 않지만 다른 컴포넌트에는 의존한다는 뜻이다.
          - 책임성이 없으며 의존적이다.
      - 모든 컴포넌트가 안정적이어야 하는 것은 아니다.
    - 추상 컴포넌트는 상당히 안정적이며, 따라서 덜 안정적인 컴포넌트가 의존할 수 있는 이상적인 대상이다.
- SAP: 안정된 추상화 원칙
  - 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
  - OCP에서는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있다.
  - 안정된 추상화 원칙
    - 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안 된다.
    - 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다.
  - 추상화 정도 측정하기
    - Nc: 컴포넌트 클래스 개수
    - Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
    - A(추상화 정도) = Na / Nc
      - A가 0이면 컴포넌트에 추상 클래스가 없다.
      - A가 1이면 추상 클래스만 있다.
      - (I, A) 
        - (0, 0) 고통의 구역, 매우 안정적이며 구체적인 컴포넌트
          - 뻣뻣한 상태, 추상적이지 않아 확장할 수 없고, 안정적이므로 변경하기도 어렵다.
          - 변동성이 없는 컴포넌트는 이 구역에 있어도 상관없다.
        - (1,1) 쓸모 없는 구역, 최고로 추상적이지만, 누구도 의존하지 않는다.
          - 누구도 구현하지 않는 추상클래스인 경우가 많다.
        - 배제 구역 벗어나기
          - 주계열: (1,0) (0, 1)을 잇는 선분
            - 가장 바람직한 지점은 주계열의 두 종점이지만 어렵다.
    - D: 거리 = |A+I-1|
      - D가 0이면 컴포넌트가 주계열 바로 위에 위치
      - 1이면 가장 멀리 위치

## 아키텍쳐
### 15. 아키텍쳐란?
- 소프트웨어 아키텍트는 최고의 프래그래머이며, 앞으로도 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이 생산성을 극대화할 수 있는 설계를 하도록 방향을 이끌어 준다.
- 아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 좋은 아키텍처는 시스템을 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 또 쉽게 배포하게 해준다.
- 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.
- 개발: 시스템 아키텍처는 개발팀이 시스템을 쉽게 개발할 수 있도록 뒷받침해야만 한다.
- 배포: 소프트웨어 아키텍처는 단 한 번에 쉽게 배포할 수 있도록 목표를 둔다.
- 운영
  - 운영을 방해하는 아키텍처가 개발, 배포, 유지보수를 방해하는 아키텍처보다 비용이 덜 든다.
  - 시스템 아키텍처는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시키고, 이들 요소가 개발자에게 주요 목표로 인식되도록 해야한다. 이를 통해 시스템을 이해하기 쉬워지며, 따라서 개발과 유지보수에 큰 도움이 된다.
### 16. 독립성
### 17. 경계: 선 긋기
### 18. 경계 해부학
### 19. 정책과 수준
### 20. 업무 규칙
### 21. 소리치는 아키텍쳐
### 22. 클린 아키텍쳐
### 23. 프레젠터와 험블 객체
### 24. 부분적 경계
### 25. 계층과 경계
### 26. 메인 컴포넌트
### 27. 크고 작은 모든 서비스들
### 28. 테스트 경계
### 29. 클린 임베디드 아키텍쳐

## 세부사항
### 30. 데이터베이스는 세부사항이다 
### 31. 웹은 세부사항이다
### 32. 프레임워크는 세부사항이다
### 33. 사례 연구: 비디오 판매
### 34. 빠져 있는 장


